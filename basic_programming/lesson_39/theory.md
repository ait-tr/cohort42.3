<details>
  <summary style="cursor: pointer;"><b>English</b></summary>



</details>

<hr>

<details style="padding-top: 18px">
  <summary style="cursor: pointer;"><b>На русском</b></summary>

# Java Collections Framework

Java Collections Framework (JCF) является важной частью Java Standard Edition (Java SE) и представляет собой набор классов и интерфейсов, которые предназначены для работы с группами (наборами) объектов. 
Коллекции упрощают работу с данными, обеспечивая методы для хранения, сортировки, поиска и доступа к элементам.

Свойство "перебираемость" = "итерируемость" - это базовое (родительское) свойство всех классов и интерфейсов, которые имеются в JCF.

## Итератор
Итератор и итерации - это корректный и безопасный способ перебора всего набора имеющихся элементов.

**Системная проблема:**
Если объект инкапсулирует внутри себя какой-то набор элементов и есть необходимость перебрать
все элементы этого набора, то с этим может возникнуть проблема.
Если для передачи этого набора создать геттер, то возвращая ссылку, мы по сути даем небезопасный
доступ к элементам набора за пределами объекта. 
Получивший этот доступ программист может без нашего ведома модифицировать объект (набор элементов) - изменить состав элементов, сократить его размер и т.д.

**Если же возвращать копию набора, то это может сильно и негативно повлиять на производительность.**

Для решения этой проблемы существует **паттерн "Итератор"** (интерфейс Iterable<>).

Суть паттерна в том, чтобы создать сторонний объект, который "знает как перебирать" (итерировать) множество
элементов, инкапсулированных в исходном объекте.

Объект итератор должен иметь две функциональности (по сути - метода):
1) знать как определить есть ли следующий элемент (метод типа boolean);
2) вернуть текущий элемент и перейти к следующему (метод, возвращающий следующий элемент множества).

В Java существует интерфейс Iterator<T> с двумя абстрактными методами:
- boolean hasNext(), возвращающий true, если еще есть элементы, и false если дошли до конца множества, и 
- T next(), возвращающий текущий элемент, и переводящий "указатель" к следующему элементу.

В интерфейсе Iterator существует еще дополнительный дефолтный метод void remove(),
который имеет пустое тело. Но если нам надо реализовать функциональность корректного удаления
текущего элемента в процессе итерирования, то метод remove надо переопределить.

Класс инкапсулирущий множество, которое надо итерировать, имплементировует (наследует) интерфейс Iterable<T>,
у которого имеется абстрактный интерфейс Iterator<T> iterator() и в нем определен метод, возвращающий итератор для объектов
данного класса.

## Интерфейс Collection
Интерфейс Collection в Java является базовым интерфейсом для всех коллекций в Java Collections Framework (JCF). 
Он предоставляет основные методы для работы с группами объектов, таких как добавление, удаление, проверка на наличие элементов и преобразование в массив.

Интерфейс Collection расширяет интерфейс Iterable, т. е. все коллекции итерируемые.
Интерфейс Collection определяет некоторый основной набор методов для работы с коллекциями данных.
Это набор CRUD-операций: добавление, удаление, поиск, обновление и другие методы, например, получение колличества элементов в коллекции и т. д.

Этот интерфейс является основой для более специализированных интерфейсов, таких как:
- List (список)
- Set (множество)
- Queue (очередь)

## Java Collection Framework

Java Collection Framework (JCF) - множество(набор) классов и интерфейсов которые реализуют наиболее часто
используемые структуры данных.

JCF состоит из двух больших подразделов: **Collection** и **Map**.
Мы начинаем наше изучение JCF с коллекций.

Интерфейс **List<E>** содержит в себе методы для **списков**.
- Обеспечивает работу с упорядоченной коллекцией элементов, которая **допускает хранение дубликатов**.
- Упорядоченность означет, что:
  - элементы в списке хранятся в том порядке, в котором они добавлены (**новые элементы встают в конец списка** по мере их добавления, сортировки при вставке не происходит). 
  - Главные методы:
    - получить элемент по его индексу методом get(int index)
    - вставить элемент add(int index, E element)
    - удалить элементы по индексу remove(int index)
    - обновить элемент по индексу set(int index, E element)
  - Поиск и выборка элементов:
    - int indexOf(Object o); 
    - int lastIndexOf(Object o); 
    - List<E> subList(int fromIndex, int toIndex);

Реализации интерфейса List<T>:

- **ArrayList<T>**:
  - Основан на массиве.
  - Быстрый доступ по индексу - это его "+".
  - Медленное удаление и вставка элементов в середину списка - это его "-".

- **LinkedList<T>**:
  - Основан на двусвязном списке.
  - Быстрая вставка и удаление элементов - это его "+"
  - Медленный доступ по индексу - это его "-".

Интерфейс Set содержит в себе методы для множеств - набора **уникальных** элементов.

----------------------------------------------

Для Iterable объектов можно использовать цикл for-each. 
Его синтаксис таков:

`for(T e: set_of_T){
    do something;
}
`
В теле этого цикла переменная "e" принимает поочередно значение каждого элемента из set_of_T

**ВНИМАНИЕ!!!**
В цикле for-each нельзя модифицировать итерируемое множество.

</details>

---------------------------------------------

# ArrayList - что это и зачем?

## Концепция массива Array:
ТИП[] имя_массива = new ТИП[размер];
Массивы хранят данные ОДНОГО ТИПА (int, String, double, ...).

В массиве данные можно сохранить и затем ими управлять:
**C - создать, R - прочитать, E|U - отредактировать или обновить, D - удалить = CRUD.**
НО с массивами "трудно" работать - необходимо следить за размером.

### Концепция коллекций Collection (Collections Framework):
**Коллекция (Collection)** в Java — это структура, которая обеспечивает
архитектуру для хранения и управления группой **Объектов (Objects)**.

**Коллекции** позволяют хранить группы Объектов, это абстракция гораздо более общего уровня,
чем массивы. Хранить и управлять коллекциями в конечном счёте удобнее, проще, чем массивами.

Для управления данными в коллекциях нужны **Интерфейсы** - способы управления/манипулирования
объектами в коллекциях. В целом интерфейсы обеспечивают примерно одно и то же - **CRUD** объектов
в коллекциях, но их реализация бывает специфична из-за различий объектов в коллекциях.

Кто-то в группе архитекторов Java очень хорошо подумал и выявил общее свойство
для хранимых данных - **ПЕРЕБИРАЕМОСТЬ(ITERABLE)**.

Интерфейс **Iterable** - "родитель" трех видов интерфейсов:
- List (Список)
- Queue (Очередь)
- Set (Множество),
  которые позволяют работать с коллекциями.

Наша с вами задача на данном этапе начать работать с классом **ArrayList**,
который имплементирует интерфейс List:
* Список - это коллекция, в которой все элементы имеют порядковый номер (индекс).

Класс **ArrayList** позволяет нам создавать объекты такого класса и ими пользоваться.

### Синтаксис создания ArrayList:
import java.util.ArrayList;

ArrayList<Тип> имяМассива = new ArrayList<>();

**примеры:**
ArrayList<Integer> myNumbersList = new ArrayList<>(); // список целых чисел
ArrayList<String> myNamesList = new ArrayList<>(); // список строк

# ArrayList подробно
В обычном массиве (Array) мы **не можем изменить размер**, он задается при создании массива.
Структура ArrayList из JCF имеет динамический размер, она расширяется автоматически по мере добавления
в него элементов. При создании собственного списка на базе ArrayList размер не указывается.

## Вопрос: ArrayList - это динамический массив?
ArrayList - реализован на базе стандартного Array.
ArrayList "на лету" создает новый массив, а не меняет размер старого,
и переносит в него содержимое старого массива.
Размер массива при каждом добавлении элемента списка увеличивается в 1,5 раза.
**Размер находящегося в памяти массива ни в одном языке программирования "на лету" изменить нельзя.**

## Вопрос: чем ArrayList лучше, чем просто Array?
- Добавление и удаление элементов легче в ArrayList - не надо думать о размере массива
- Поиск, проверка элемента на наличие легче - используем встроенный метод contains()
- Сортировка для ArrayList реализована стандартными методами в Collections, для Array не надо писать самим
- Можно ли в ArrayList добавить null - ответ ДА
- Можно ли в ArrayList добавить дубликат(ы) - ответ ДА
- можно использовать цикл for each для пробегания по элементам массива, есть ограничения по модификации
  в момент обхода (нежелательно удалять элементы коллекции)

## Вопрос: бывает ли ArrayList двух и более мерным?
Ответ - грубо говоря, нет, так не делают.
В теории мы можем построить ArrayList<ArrayList1>.
На практике для задач с многомерными массивами лучше использовать стандартный Array[][].

## ArrayList - прямое заполнение методом asList
ArrayList<String> namesList = new ArrayList<String>(Arrays.asList("Peter","Vladimir","Stepan"));
System.out.println(namesList);